package com.github.yeriomin.playstoreapi;

import java.io.IOException;
import java.math.BigInteger;
import java.util.*;

/**
 * This class provides
 * <code>checkin, search, details, bulkDetails, browse, list and download</code>
 * capabilities. It uses <code>Apache Commons HttpClient</code> for POST and GET
 * requests.
 *
 * @author akdeniz, yeriomin
 */
public class GooglePlayAPI {

    private static final String SCHEME = "https://";
    private static final String HOST = "android.clients.google.com";
    private static final String CHECKIN_URL = SCHEME + HOST + "/checkin";
    private static final String URL_LOGIN = SCHEME + HOST + "/auth";
    private static final String C2DM_REGISTER_URL = SCHEME + HOST + "/c2dm/register2";
    private static final String FDFE_URL = SCHEME + HOST + "/fdfe/";
    private static final String LIST_URL = FDFE_URL + "list";
    private static final String BROWSE_URL = FDFE_URL + "browse";
    private static final String DETAILS_URL = FDFE_URL + "details";
    private static final String SEARCH_URL = FDFE_URL + "search";
    private static final String BULKDETAILS_URL = FDFE_URL + "bulkDetails";
    private static final String PURCHASE_URL = FDFE_URL + "purchase";
    private static final String REVIEWS_URL = FDFE_URL + "rev";
    private static final String UPLOADDEVICECONFIG_URL = FDFE_URL + "uploadDeviceConfig";
    private static final String RECOMMENDATIONS_URL = FDFE_URL + "rec";

    private static final String ACCOUNT_TYPE_HOSTED_OR_GOOGLE = "HOSTED_OR_GOOGLE";

    public enum REVIEW_SORT {
        NEWEST(0), HIGHRATING(1), HELPFUL(2);

        public int value;

        REVIEW_SORT(int value) {
            this.value = value;
        }
    }

    public enum RECOMMENDATION_TYPE {
        ALSO_VIEWED(1), ALSO_INSTALLED(2);

        public int value;

        RECOMMENDATION_TYPE(int value) {
            this.value = value;
        }
    }

    ThrottledOkHttpClient client;
    private Locale locale;
    private DeviceInfoProvider deviceInfoProvider;

    private String email;
    private String password;

    /**
     * Auth token
     * Seems to have a very long lifetime - months
     * So, it is a good idea to save and reuse it
     */
    private String token;

    /**
     * Google Services Framework id
     * Incorrectly called Android id and Device id sometimes
     * Is generated by a checkin request in getGsfId()
     * It is a good idea to save and reuse it
     */
    private String gsfId;

    ThrottledOkHttpClient getClient() {
        if (this.client == null) {
            this.client = new ThrottledOkHttpClient();
        }
        return this.client;
    }

    public void setLocale(Locale locale) {
        this.locale = locale;
    }

    public void setDeviceInfoProvider(DeviceInfoProvider deviceInfoProvider) {
        this.deviceInfoProvider = deviceInfoProvider;
    }

    public GooglePlayAPI(String email, String password) {
        this.email = email;
        this.password = password;
    }

    public void setToken(String token) {
        this.token = token;
    }

    public void setGsfId(String gsfId) {
        this.gsfId = gsfId;
    }

    /**
     * Performs authentication on "ac2dm" service and match up gsf id,
     * security token and email by checking them in on this server.
     * <p>
     * This function sets check-inded gsf id and that can be taken either by
     * using <code>getToken()</code> or from returned
     * {@link AndroidCheckinResponse} instance.
     */
    public String getGsfId() throws IOException {
        AndroidCheckinRequest request = this.deviceInfoProvider.generateAndroidCheckinRequest();

        // this first checkin is for generating android-id
        AndroidCheckinResponse checkinResponse = checkin(request.toByteArray());
        this.gsfId = BigInteger.valueOf(checkinResponse.getAndroidId()).toString(16);
        String securityToken = BigInteger.valueOf(checkinResponse.getSecurityToken()).toString(16);

        AndroidCheckinRequest.Builder checkInbuilder = AndroidCheckinRequest.newBuilder(request);
        String AC2DMToken = getAC2DMToken();
        AndroidCheckinRequest build = checkInbuilder
            .setId(new BigInteger(this.gsfId, 16).longValue())
            .setSecurityToken(new BigInteger(securityToken, 16).longValue())
            .addAccountCookie("[" + this.email + "]")
            .addAccountCookie(AC2DMToken)
            .build();
        // this is the second checkin to match credentials with android-id
        checkin(build.toByteArray());

        return this.gsfId;
    }

    /**
     * Posts given check-in request content and returns
     * {@link AndroidCheckinResponse}.
     */
    private AndroidCheckinResponse checkin(byte[] request) throws IOException {
        Map<String, String> headers = getDefaultHeaders();
        headers.put("Content-Type", "application/x-protobuffer");
        byte[] content = getClient().post(CHECKIN_URL, request, headers);
        return AndroidCheckinResponse.parseFrom(content);
    }

    /**
     * Authenticates on server with given email and password and sets
     * authentication token. This token can be used to login instead of using
     * email and password every time.
     */
    public String getToken() throws IOException {
        Map<String, String> params = getDefaultLoginParams();
        params.put("service", "androidmarket");
        params.put("app", "com.android.vending");
        params.put("androidId", this.gsfId);
        byte[] responseBytes = getClient().post(URL_LOGIN, params, getDefaultHeaders());
        Map<String, String> response = parseResponse(new String(responseBytes));
        if (response.containsKey("Auth")) {
            return response.get("Auth");
        } else {
            throw new GooglePlayException("Authentication failed! (login)");
        }
    }

    /**
     * Logins AC2DM server and returns authentication string.
     *
     * client_sig is SHA1 digest of encoded certificate on
     * <i>GoogleLoginService(package name : com.google.android.gsf)</i> system APK.
     * But google doesn't seem to care of value of this parameter.
     */
    public String getAC2DMToken() throws IOException {
        Map<String, String> params = getDefaultLoginParams();
        params.put("service", "ac2dm");
        params.put("add_account", "1");
        params.put("app", "com.google.android.gsf");
        byte[] responseBytes = getClient().post(URL_LOGIN, params, getDefaultHeaders());
        Map<String, String> response = parseResponse(new String(responseBytes));
        if (response.containsKey("Auth")) {
            return response.get("Auth");
        } else {
            throw new GooglePlayException("Authentication failed! (loginAC2DM)");
        }
    }

    public Map<String, String> c2dmRegister(String application, String sender) throws IOException {
        Map<String, String> params = new HashMap<>();
        params.put("app", application);
        params.put("sender", sender);
        params.put("device", new BigInteger(this.gsfId, 16).toString());
        Map<String, String> headers = getDefaultHeaders();
        headers.put("Authorization", "GoogleLogin auth=" + getAC2DMToken());
        byte[] responseBytes = getClient().post(C2DM_REGISTER_URL, params, headers);
        return parseResponse(new String(responseBytes));
    }

    /**
     * Equivalent of <code>search(query, null, null)</code>
     */
    public SearchResponse search(String query) throws IOException {
        return search(query, null, null);
    }

    /**
     * Fetches a search results for given query.
     * Offset and numberOfResults parameters are optional.
     *
     * Warning! offset and numberOfResults do not seem to work anymore.
     * The api always returns a fixed number of results. And always the first results.
     * Fetching further results is done through next page url returned with the search result.
     *
     * @deprecated Use getSearchIterator() instead.
     */
    public SearchResponse search(String query, Integer offset, Integer numberOfResults) throws IOException {
        String url = SEARCH_URL;
        Map<String, String> params = getDefaultGetParams(offset, numberOfResults);
        params.put("q", query);

        byte[] responseBytes = getClient().get(url, params, getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getSearchResponse();
    }

    /**
     * Search - the new way
     * Returns an iterator which requests the first search result page and then remembers the next page urls
     * provided with each next response.
     *
     * @param query
     * @return SearchIterator
     */
    public SearchIterator getSearchIterator(String query) {
        return new SearchIterator(query);
    }

    /**
     * Fetches detailed information about passed package name. If it is needed
     * to fetch information about more than one application, consider using bulkDetails
     */
    public DetailsResponse details(String packageName) throws IOException {
        Map<String, String> params = new HashMap<>();
        params.put("doc", packageName);

        byte[] responseBytes = getClient().get(DETAILS_URL, params, getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getDetailsResponse();
    }

    /**
     * Fetches detailed information about each of the package names specified
     */
    public BulkDetailsResponse bulkDetails(List<String> packageNames) throws IOException {
        BulkDetailsRequest.Builder bulkDetailsRequestBuilder = BulkDetailsRequest.newBuilder();
        bulkDetailsRequestBuilder.addAllDocid(packageNames);
        byte[] request = bulkDetailsRequestBuilder.build().toByteArray();

        byte[] responseBytes = getClient().post(BULKDETAILS_URL, request, getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getBulkDetailsResponse();
    }

    /**
     * Fetches available categories
     */
    public BrowseResponse browse() throws IOException {
        return browse(null, null);
    }

    public BrowseResponse browse(String categoryId, String subCategoryId) throws IOException {
        Map<String, String> params = getDefaultGetParams(null, null);
        if (null != categoryId && !categoryId.isEmpty()) {
            params.put("cat", categoryId);
        }
        if (null != subCategoryId && !subCategoryId.isEmpty()) {
            params.put("ctr", subCategoryId);
        }
        byte[] responseBytes = getClient().get(BROWSE_URL, params, getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getBrowseResponse();
    }

    /**
     * Equivalent of <code>list(categoryId, null, null, null)</code>. It fetches
     * sub-categories of given category!
     */
    public ListResponse list(String categoryId) throws IOException {
        return list(categoryId, null, null, null);
    }

    /**
     * Fetches applications within supplied category and sub-category. If
     * <code>null</code> is given for sub-category, it fetches sub-categories of
     * passed category.
     * <p>
     * Default values for offset and numberOfResult are "0" and "20"
     * respectively. These values are determined by Google Play Store.
     */
    public ListResponse list(String categoryId, String subCategoryId, Integer offset, Integer numberOfResults) throws IOException {
        Map<String, String> params = getDefaultGetParams(offset, numberOfResults);
        params.put("cat", categoryId);
        params.put("ctr", subCategoryId);
        byte[] responseBytes = getClient().get(LIST_URL, params, getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getListResponse();
    }

    /**
     * This function is used for fetching download url and download cookie,
     * rather than actual purchasing.
     */
    public BuyResponse purchase(String packageName, int versionCode, int offerType) throws IOException {
        Map<String, String> params = new HashMap<>();
        params.put("ot", String.valueOf(offerType));
        params.put("doc", packageName);
        params.put("vc", String.valueOf(versionCode));
        byte[] responseBytes = getClient().post(PURCHASE_URL, params, getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getBuyResponse();
    }

    /**
     * Fetches the reviews of given package name by sorting passed choice.
     * <p>
     * Default values for offset and numberOfResult are "0" and "20"
     * respectively. These values are determined by Google Play Store.
     */
    public ReviewResponse reviews(String packageName, REVIEW_SORT sort, Integer offset, Integer numberOfResults) throws IOException {
        Map<String, String> params = getDefaultGetParams(offset, numberOfResults);
        params.put("doc", packageName);
        params.put("sort", (sort == null) ? null : String.valueOf(sort.value));
        byte[] responseBytes = getClient().get(REVIEWS_URL, params, getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getReviewResponse();
    }

    /**
     * Uploads device configuration to google server so that can be seen from
     * web as a registered device!!
     * If this is not done, some apps magically disappear from search responses
     */
    public UploadDeviceConfigResponse uploadDeviceConfig() throws IOException {
        UploadDeviceConfigRequest request = UploadDeviceConfigRequest.newBuilder()
            .setDeviceConfiguration(this.deviceInfoProvider.getDeviceConfigurationProto())
            .build();
        byte[] responseBytes = getClient().post(UPLOADDEVICECONFIG_URL, request.toByteArray(), getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getUploadDeviceConfigResponse();
    }

    /**
     * Fetches the recommendations of given package name.
     * <p>
     * Default values for offset and numberOfResult are "0" and "20"
     * respectively. These values are determined by Google Play Store.
     */
    public ListResponse recommendations(String packageName, RECOMMENDATION_TYPE type, Integer offset, Integer numberOfResults) throws IOException {
        Map<String, String> params = getDefaultGetParams(offset, numberOfResults);
        params.put("doc", packageName);
        params.put("rt", (type == null) ? null : String.valueOf(type.value));
        byte[] responseBytes = getClient().get(RECOMMENDATIONS_URL, params, getDefaultHeaders());
        return ResponseWrapper.parseFrom(responseBytes).getPayload().getListResponse();
    }

    /**
     * login methods use this
     * Most likely not all of these are required, but the Market app sends them, so we will too
     *
     */
    private Map<String, String> getDefaultLoginParams() {
        Map<String, String> params = new HashMap<>();
        params.put("Email", this.email);
        params.put("Passwd", this.password);
        params.put("accountType", ACCOUNT_TYPE_HOSTED_OR_GOOGLE);
        params.put("has_permission", "1");
        params.put("source", "android");
        params.put("device_country", this.locale.getCountry().toLowerCase());
        params.put("lang", this.locale.getLanguage().toLowerCase());
        params.put("sdk_version", String.valueOf(this.deviceInfoProvider.getSdkVersion()));
        params.put("client_sig", "38918a453d07199354f8b19af05ec6562ced5788");
        return params;
    }

    /**
     * Using Accept-Language you can fetch localized informations such as reviews and descriptions.
     * Note that changing this value has no affect on localized application list that
     * server provides. It depends on only your IP location.
     * 
     */
    private Map<String, String> getDefaultHeaders() {
        Map<String, String> headers = new HashMap<>();
        if (this.token != null && !this.token.isEmpty()) {
            headers.put("Authorization", "GoogleLogin auth=" + this.token);
        }
        headers.put("User-Agent", this.deviceInfoProvider.getUserAgentString());
        if (this.gsfId != null && !this.gsfId.isEmpty()) {
            headers.put("X-DFE-Device-Id", this.gsfId);
        }
        headers.put("Accept-Language", this.locale.toString().replace("_", "-"));
        return headers;
    }

    /**
     * Most list requests (apps, categories,..) take these params
     *
     * @param offset
     * @param numberOfResults
     */
    private Map<String, String> getDefaultGetParams(Integer offset, Integer numberOfResults) {
        Map<String, String> params = new HashMap<>();
        // "c=3" is to get apps only, not books, music, or movies
        params.put("c", "3");
        if (offset != null) {
            params.put("o", String.valueOf(offset));
        }
        if (numberOfResults != null) {
            params.put("n", String.valueOf(numberOfResults));
        }
        return params;
    }

    /**
     * Some methods instead of a protobuf return key-value pairs on each string
     *
     * @param response
     */
    private static Map<String, String> parseResponse(String response) {
        Map<String, String> keyValueMap = new HashMap<>();
        StringTokenizer st = new StringTokenizer(response, "\n\r");
        while (st.hasMoreTokens()) {
            String[] keyValue = st.nextToken().split("=");
            keyValueMap.put(keyValue[0], keyValue[1]);
        }
        return keyValueMap;
    }

    /**
     * Iterates through search result pages
     * Each next() call gets you a next page of search results for the provided query
     */
    public class SearchIterator implements Iterator<SearchResponse> {

        private boolean firstQuery = true;
        private final String query;
        private String nextPageUrl;

        SearchIterator(String query) {
            this.query = query;
        }

        public String getQuery() {
            return query;
        }

        @Override
        public boolean hasNext() {
            return this.firstQuery || (null != this.nextPageUrl && !this.nextPageUrl.isEmpty());
        }

        @Override
        public SearchResponse next() {
            String url = SEARCH_URL;
            Map<String, String> params = new HashMap<>();
            if (this.firstQuery) {
                params.put("c", "3");
                params.put("q", query);
            } else if (null != this.nextPageUrl && !this.nextPageUrl.isEmpty()) {
                url = this.nextPageUrl;
            } else {
                throw new NoSuchElementException();
            }

            SearchResponse response;
            try {
                byte[] responseBytes = getClient().get(url, params, getDefaultHeaders());
                response = ResponseWrapper.parseFrom(responseBytes).getPayload().getSearchResponse();
                this.firstQuery = false;
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

            if (null != response
                && response.getDocCount() > 0
                && response.getDocList().get(0).hasContainerMetadata()
                && response.getDocList().get(0).getContainerMetadata().hasNextPageUrl()
            ) {
                this.nextPageUrl = FDFE_URL + response.getDocList().get(0).getContainerMetadata().getNextPageUrl();
            } else {
                this.nextPageUrl = null;
            }
            return response;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
}
